package REST_API.contorller;


import REST_API.exceptions.UserAlreadyExistException;
import REST_API.exceptions.UserNoExistException;
import REST_API.model.Group;
import REST_API.model.Schedule;
import REST_API.repository.GroupDAO;
import REST_API.repository.ScheduleDAO;
import REST_API.repository.UserDAO;
import REST_API.model.User;
import REST_API.repository.jdbc.JDBCTemplateUserDAOImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.Date;
import java.util.List;

@Controller// This means that this class is a Controller
@RequestMapping(path="/api") // This means URL's start with /demo (after REST_API.Application path)
public class UserController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserDAO userRepository;
    private GroupDAO groupRepository;
    private ScheduleDAO scheduleRepository;


    @Autowired
    private JDBCTemplateUserDAOImpl jdbcTemplateUserDao;

//    @PostMapping(value = "/add")
//    public ResponseEntity<?> addNewUser(@RequestBody User client) {
//        userRepository.createUser(client);
//        return new ResponseEntity<>(HttpStatus.CREATED);
//    }

    @GetMapping(value = "/getLessons")
    public ResponseEntity<List<Schedule>> showLessonsOnMonth(@RequestBody User user) {
        final List<Schedule> lessons = scheduleRepository.getLessonsOnMonth(user);

        return lessons != null &&  !lessons.isEmpty()
                ? new ResponseEntity<>(lessons, HttpStatus.OK)
                : new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }


    @PostMapping(path="/add") // Map ONLY POST Requests
    public @ResponseBody String addNewUser (@RequestParam int id, @RequestParam String name
            , @RequestParam String email, @RequestParam String password
            , @RequestParam Date date_of_reg, @RequestParam int group_id) {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        User n = new User();
        Group g = new Group();
        n.setId(id);
        n.setName(name);
        n.setEmail(email);
        n.setDate_of_reg(date_of_reg);
        g.setId(group_id);
        n.setGroup(groupRepository.getGroupById(group_id));
        userRepository.createUser(n);
        return "Saved";
    }

    @GetMapping(path="/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    //Авторизация++
//    @PostMapping("/authorization")
//    public String authorization(@RequestBody User user) throws UserNoExistException {
//        try{
//            User user2 = userService.authorization(user);
//
//        } catch (Exception e){
//            return null;
//        }
//        return null;
//    }


    //Получение токена(для тестов)++
//    @PostMapping("/getMyUser")
//    public User pepe() throws UserNoExistException {
//        String token = jwtFilter.returnToken();
//        return jdbcTemplateUserDao.getUserById( Integer.parseInt(jwtProvider.getIdFromToken(token)));
//    }

    //Создание пользователя(регистрация)++
//    @PostMapping("/registration")
//    public ResponseEntity registration(@RequestBody User user){
//        try {
//            userService.registration(user);
//            return ResponseEntity.ok("User has been successfully saved");
//        } catch (UserAlreadyExistException e){
//            return ResponseEntity.badRequest().body(e.getMessage());
//        } catch (Exception e){
//            return ResponseEntity.badRequest().body("Error");
//        }
//    }


    //Изменение пароля пользователя++
//    @PostMapping("/updatePassword")
//    public String updatePassword(@RequestBody UpdatePassword obj){
//        try {
//            String token = jwtFilter.returnToken();
//            userService.updatePassword(jwtProvider.getLoginFromToken(token),
//                    obj.getPassword(), obj.getNewPassword());
//
//            User user2 = userService.authorization(jdbcTemplateUserDao.getUserByEmail(jwtProvider.getLoginFromToken(token)));
//            String tokenNew = jwtProvider.generateToken(user2.getEmail(), obj.getNewPassword(), user2.getId());
//            return tokenNew;
//
//        } catch (Exception e){
//            return "Error";
//        }
//    }
//
//
//    //Изменение логина пользователя++
//    @PostMapping("/updateLogin")
//    public String updateLogin(@RequestBody UpdateEmail obj){
//        try {
//            String token = jwtFilter.returnToken();
//            User user2 = jdbcTemplateUserDao.getUserByEmail(jwtProvider.getLoginFromToken(token));
//            userService.updateLogin(Integer.parseInt(jwtProvider.getIdFromToken(token)), obj.getEmail(), obj.getNewEmail());
//
//            String tokenNew = jwtProvider.generateToken(obj.getNewEmail(), user2.getPassword(), user2.getId());
//            return tokenNew;
//        } catch (Exception e){
//            return "Error";
//        }
//    }
//
//    //Удаление аккаунта пользователя++
//    @PostMapping("/deleteAccount")
//    public ResponseEntity removeAccount(){
//        try {
//            String token = jwtFilter.returnToken();
//            userService.delete(Integer.parseInt(jwtProvider.getIdFromToken(token)));
//            return ResponseEntity.ok("User has been successfully removed");
//        } catch (UserNoExistException e) {
//            return ResponseEntity.badRequest().body(e.getMessage());
//        } catch (Exception e){
//            return ResponseEntity.badRequest().body("Error");
//        }
//    }
}